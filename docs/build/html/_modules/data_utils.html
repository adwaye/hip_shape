

<!DOCTYPE html>
<html class="writer-html5" lang="python" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>data_utils &mdash; hip_shape 0.0.1 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> hip_shape
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"></div>
            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">hip_shape</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>data_utils</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for data_utils</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pymeshlab</span> <span class="k">as</span> <span class="nn">ml</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">plotly.graph_objects</span> <span class="k">as</span> <span class="nn">go</span>
<span class="kn">import</span> <span class="nn">plotly.io</span> <span class="k">as</span> <span class="nn">pio</span>
<span class="n">pio</span><span class="o">.</span><span class="n">renderers</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="s2">&quot;browser&quot;</span>
<span class="kn">import</span> <span class="nn">meshlib.mrmeshpy</span> <span class="k">as</span> <span class="nn">mr</span>
<span class="kn">import</span> <span class="nn">stl</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">os.path</span>

<span class="kn">import</span> <span class="nn">plotly.graph_objects</span>
<span class="kn">import</span> <span class="nn">plotly.graph_objects</span> <span class="k">as</span> <span class="nn">go</span>
<span class="kn">import</span> <span class="nn">plotly.io</span> <span class="k">as</span> <span class="nn">pio</span>
<span class="n">pio</span><span class="o">.</span><span class="n">renderers</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="s2">&quot;browser&quot;</span>
<span class="kn">from</span> <span class="nn">read_landmarks</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">numpy.linalg</span>
<span class="kn">from</span> <span class="nn">skspatial.objects</span> <span class="kn">import</span> <span class="n">Plane</span><span class="p">,</span> <span class="n">Points</span>
<span class="kn">from</span> <span class="nn">skspatial.plotting</span> <span class="kn">import</span> <span class="n">plot_3d</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
<span class="kn">from</span> <span class="nn">utils</span> <span class="kn">import</span> <span class="n">_embed_points_in_array</span><span class="p">,</span><span class="n">jax_rotation_matrix3d</span><span class="p">,</span><span class="n">_make_distance_transform</span><span class="p">,</span><span class="n">eval_distance</span><span class="p">,</span>\
    <span class="n">jax_eval_distance</span><span class="p">,</span><span class="n">jax_pitch_matrix</span><span class="p">,</span><span class="n">jax_roll_matrix</span><span class="p">,</span><span class="n">jax_yaw_matrix</span><span class="p">,</span><span class="n">affine_cost</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span> <span class="k">as</span> <span class="n">ndi</span>
<span class="kn">from</span> <span class="nn">jax.scipy</span> <span class="kn">import</span> <span class="n">ndimage</span> <span class="k">as</span> <span class="n">jndi</span>
<span class="kn">import</span> <span class="nn">jax.scipy.optimize</span> <span class="k">as</span> <span class="nn">optimize</span>
<span class="kn">import</span> <span class="nn">jax.numpy</span> <span class="k">as</span> <span class="nn">jnp</span>
<span class="kn">import</span> <span class="nn">edt</span> <span class="c1">#got this from https://github.com/seung-lab/euclidean-distance-transform-3d</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">threading</span> <span class="k">as</span> <span class="nn">t</span>


<span class="n">source_loc</span> <span class="o">=</span> <span class="s1">&#39;data/Segmentation_and_landmarks_raw/&#39;</span>
<span class="n">target_loc</span> <span class="o">=</span> <span class="s1">&#39;data/Segmentation_and_landmarks_processed/&#39;</span>
<span class="n">APP_aligned_loc</span> <span class="o">=</span> <span class="s1">&#39;data/Segmentation_and_landmarks_APP_aligned/&#39;</span>
<span class="n">RSocket_aligned_trans</span> <span class="o">=</span> <span class="s1">&#39;data/Segmentation_and_landmarks_Rsocket_aligned/&#39;</span>
<span class="n">LSocket_aligned_trans</span> <span class="o">=</span> <span class="s1">&#39;data/Segmentation_and_landmarks_Lsocket_aligned/&#39;</span>
<span class="n">dtype</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">float32</span>




<div class="viewcode-block" id="HipData"><a class="viewcode-back" href="../data_utils.html#data_utils.HipData">[docs]</a><span class="k">class</span> <span class="nc">HipData</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Data class for hip surfaces</span>

<span class="sd">    :param pickle_path: path to pickle file. Needs to be the output of data_cleaning._to_pickle</span>
<span class="sd">    :type pickle_path: str</span>
<span class="sd">    :param decimator: object that provided an interface to downsample the number of faces in self.data[&#39;surface][&#39;RPEL&#39;]</span>
<span class="sd">                      and self.data[&#39;surface][&#39;LPEL&#39;]</span>
<span class="sd">    :type decimator: MeshDecimator or None</span>

<span class="sd">    &gt;&gt;&gt; decimator = MeshLibDecimator()</span>
<span class="sd">    &gt;&gt;&gt; path = os.path.join(&#39;data/Segmentation_and_landmarks_processed/TOH - Controls/C10.p&#39;)</span>
<span class="sd">    &gt;&gt;&gt; hip_data = HipData(pickle_path=path,decimator=decimator)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pickle_path</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span><span class="n">decimator</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">pickle_path</span> <span class="o">=</span> <span class="n">pickle_path</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pickle_path</span><span class="p">,</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span>   <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decimator</span> <span class="o">=</span> <span class="n">decimator</span>
        <span class="c1"># try:</span>
        <span class="c1">#     self.rot_mat    = self.data[&#39;rotmat&#39;]</span>
        <span class="c1"># except KeyError:</span>
        <span class="c1">#     self.rot_mat = None</span>
        <span class="c1">#</span>
        <span class="c1"># try:</span>
        <span class="c1">#     self.trans_vect = self.data[&#39;trans_vect&#39;]</span>
        <span class="c1"># except KeyError:</span>
        <span class="c1">#     self.trans_vect = None</span>


<div class="viewcode-block" id="HipData.rotate"><a class="viewcode-back" href="../data_utils.html#data_utils.HipData.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">points</span><span class="p">:</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Rotates a set of points by using self.rot_mat. if self.rot_mat is None, returns the points as is</span>

<span class="sd">        :param points: points to be rotated</span>
<span class="sd">        :type points: array shape (3,N)</span>
<span class="sd">        :return: rotated points</span>
<span class="sd">        :rtype: array shape (N,3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="mi">3</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">3</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">center</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">points_</span> <span class="o">=</span> <span class="n">points</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">points</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">,</span><span class="n">points_</span><span class="p">)</span><span class="o">+</span><span class="n">center</span>

            <span class="c1">#print(&#39;no rotation matrix found in data&#39;)</span>


        <span class="k">return</span> <span class="n">points</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span></div>

<div class="viewcode-block" id="HipData.translate"><a class="viewcode-back" href="../data_utils.html#data_utils.HipData.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">points</span><span class="p">:</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Rotates a set of points by using self.trans_vect. if self.trans_vect is None, returns the points as is</span>

<span class="sd">        :param points: points to be rotated</span>
<span class="sd">        :type points: array shape (N,3)</span>
<span class="sd">        :return: translated points</span>
<span class="sd">        :rtype: array shape (N,3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">3</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans_vect</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">points</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans_vect</span>

            <span class="c1">#print(&#39;no translation vector found in data&#39;)</span>


        <span class="k">return</span> <span class="n">points</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">APP_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns the app plane coodinates</span>

<span class="sd">        :return: array shape (4,3) containing the APP coordinates</span>
<span class="sd">        :rtype:np.array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;RASIS&#39;</span><span class="p">,</span><span class="s1">&#39;LASIS&#39;</span><span class="p">,</span><span class="s1">&#39;RTUB&#39;</span><span class="p">,</span><span class="s1">&#39;LTUB&#39;</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;landmarks&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">points_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;landmarks&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">points</span><span class="p">,</span><span class="n">points_</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">k</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;cannot find </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">points</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">RPEL</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns the right pelvis point cloud. if self.rot_mat is not None, the points are rotated.</span>
<span class="sd">        Similarly if self.trans_vect is not None, the points are translated</span>

<span class="sd">        :return: list if points,faces where</span>
<span class="sd">                     **points**: np.array shape [N1,3] of vertices.</span>
<span class="sd">                     **faces** : np.array shape [N2,3] of simplices where vertices[faces[:,i]] would be the coordinates of the i-th vertex in each triangle.</span>
<span class="sd">        :rtype: np.array</span>
<span class="sd">        :rtype: list(np.array)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">][</span><span class="s1">&#39;RPel&#39;</span><span class="p">][</span><span class="s1">&#39;points&#39;</span><span class="p">]</span>
            <span class="n">faces</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">][</span><span class="s1">&#39;RPel&#39;</span><span class="p">][</span><span class="s1">&#39;faces&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">faces</span>  <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">points</span><span class="p">,</span><span class="n">faces</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">LPEL</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns the left pelvis point cloud. if self.rot_mat is not None, the points are rotated.</span>
<span class="sd">        Similarly if self.trans_vect is not None, the points are translated</span>

<span class="sd">        :return: list if points,faces where</span>
<span class="sd">                 **points**: np.array shape [N1,3] of vertices.</span>
<span class="sd">                 **faces** : np.array shape [N2,3] of simplices where vertices[faces[:,i]] would be the coordinates of the i-th vertex in each triangle.</span>
<span class="sd">        :rtype: list(np.array)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">][</span><span class="s1">&#39;LPel&#39;</span><span class="p">][</span><span class="s1">&#39;points&#39;</span><span class="p">]</span>
            <span class="n">faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">][</span><span class="s1">&#39;LPel&#39;</span><span class="p">][</span><span class="s1">&#39;faces&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">faces</span>  <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">points</span><span class="p">,</span><span class="n">faces</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">right_socket</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns the right socket plane crest points. if self.rot_mat is not None, the points are rotated.</span>
<span class="sd">        Similarly if self.trans_vect is not None, the points are translated</span>

<span class="sd">        :return: points correponding to the socket opening plane shape (N,3)</span>
<span class="sd">        :rtype: np.array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">side</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Right&#39;</span><span class="p">]:</span>  <span class="c1">#[&#39;Right&#39;,&#39;Left&#39;]:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Ant Lat&#39;</span><span class="p">,</span><span class="s1">&#39;Post Lat&#39;</span><span class="p">]:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;landmarks&#39;</span><span class="p">][</span><span class="n">side</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">key</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">points_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;landmarks&#39;</span><span class="p">][</span><span class="n">side</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">key</span><span class="p">]</span>

                        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">points</span><span class="p">,</span><span class="n">points_</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cannot find &#39;</span> <span class="o">+</span> <span class="n">side</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">key</span><span class="p">)</span>

        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">points</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">left_socket</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns the left socket plane crest points. if self.rot_mat is not None, the points are rotated.</span>
<span class="sd">        Similarly if self.trans_vect is not None, the points are translated</span>

<span class="sd">        :return: points correponding to the socket opening plane shape (N,3)</span>
<span class="sd">        :rtype: np.array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">side</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Left&#39;</span><span class="p">]:</span>  <span class="c1">#[&#39;Right&#39;,&#39;Left&#39;]:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Ant Lat&#39;</span><span class="p">,</span><span class="s1">&#39;Post Lat&#39;</span><span class="p">]:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;landmarks&#39;</span><span class="p">][</span><span class="n">side</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">key</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">points_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;landmarks&#39;</span><span class="p">][</span><span class="n">side</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">key</span><span class="p">]</span>

                        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">points</span><span class="p">,</span><span class="n">points_</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cannot find &#39;</span> <span class="o">+</span> <span class="n">side</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">points</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rot_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the rotation matrix that makes the data rotation invariant. Will usually align to a pre decided template. Returns None if not present</span>

<span class="sd">        :return: rotation matrix np.array shape (3,3) or None is no rotation invariance has been imposed</span>
<span class="sd">        :rtype: np.array or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">rot_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;rotmat&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">rot_mat</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">rot_mat</span>


    <span class="nd">@rot_mat</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">rot_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;sets the rotation matrix to impose rotation invariance</span>

<span class="sd">        :param val: rotation matrix shape (3,3)</span>
<span class="sd">        :type val: np.array</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;rotmat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
<span class="c1">#        self.rot_mat = val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">trans_vect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the translation vector required to make the data translation invariant</span>

<span class="sd">        :return: vector shape (1,3) or None if no translation invariance has been imposed</span>
<span class="sd">        :rtype: np.array or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">trans_vect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;translation&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">trans_vect</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">trans_vect</span>

    <span class="nd">@trans_vect</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">trans_vect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span><span class="p">:</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the translation vector required to make the data translation invariant</span>

<span class="sd">        :param val: shape (1,3)</span>
<span class="sd">        :type val: np.array</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;translation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="c1">#self.rot_mat = val</span>


<div class="viewcode-block" id="HipData.save_data"><a class="viewcode-back" href="../data_utils.html#data_utils.HipData.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">location</span><span class="p">:</span><span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span><span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Saves self.data as a pickle file. The saved file name is the same as the original filename. The pickle file is saved in location/self.pickle_path</span>

<span class="sd">        :param location: path pointing to a folder where the pickle file should saved</span>
<span class="sd">        :type location: str</span>
<span class="sd">        :return:</span>
<span class="sd">        :rtype:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">location</span><span class="p">):</span> <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
        <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">location</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">pickle_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span><span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">fp</span><span class="p">,</span><span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pickle_path</span> <span class="o">=</span> <span class="n">file_path</span></div>


<div class="viewcode-block" id="HipData.get_plotly_graph"><a class="viewcode-back" href="../data_utils.html#data_utils.HipData.get_plotly_graph">[docs]</a>    <span class="k">def</span> <span class="nf">get_plotly_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">color</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;lightpink&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the plotly 3d graph associated with each of the left and right pelvis</span>

<span class="sd">        :return: [left_mesh_plot,right_mesh_plot] left and right pelvis pot objects</span>
<span class="sd">        :rtype: tuple(plotly.graph_objects.Mesh3d,plotly.graph_objects.Mesh3d)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">left_mesh_plot</span>  <span class="o">=</span> <span class="kc">None</span>
        <span class="n">right_mesh_plot</span> <span class="o">=</span> <span class="kc">None</span>


        <span class="n">r_mesh</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RPEL</span>
        <span class="n">l_mesh</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LPEL</span>
        <span class="k">if</span> <span class="n">r_mesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vertices</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">K</span> <span class="o">=</span> <span class="n">points2mesh3d</span><span class="p">(</span><span class="n">r_mesh</span><span class="p">)</span><span class="c1">#-np.mean(self.RPEL[0],axis=0,keepdims=True))</span>
            <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">T</span>
            <span class="n">right_mesh_plot</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Mesh3d</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span>
                                             <span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">y</span>
                                             <span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="n">z</span>
                                             <span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="n">I</span>
                                             <span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">J</span>
                                             <span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="n">K</span>
                                             <span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span><span class="n">opacity</span><span class="o">=</span><span class="mf">0.50</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">l_mesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vertices</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">K</span> <span class="o">=</span> <span class="n">points2mesh3d</span><span class="p">(</span><span class="n">l_mesh</span><span class="p">)</span><span class="c1">#-np.mean(self.RPEL[0],axis=0,keepdims=True))</span>
            <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">T</span>
            <span class="n">left_mesh_plot</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Mesh3d</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span>
                                             <span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">y</span>
                                             <span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="n">z</span>
                                             <span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="n">I</span>
                                             <span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">J</span>
                                             <span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="n">K</span>
                                             <span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span><span class="n">opacity</span><span class="o">=</span><span class="mf">0.50</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">left_mesh_plot</span><span class="p">,</span><span class="n">right_mesh_plot</span></div>


<div class="viewcode-block" id="HipData.decimate"><a class="viewcode-back" href="../data_utils.html#data_utils.HipData.decimate">[docs]</a>    <span class="k">def</span> <span class="nf">decimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">max_num_faces</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span><span class="n">save_path</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">step_size</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span><span class="n">max_it</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span><span class="o">-&gt;</span><span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calls meshlib to reduce the number of faces in the RPel and LPel surfaces.</span>

<span class="sd">        :param max_num_faces: maximum number of faces</span>
<span class="sd">        :type max_num_faces: int</span>
<span class="sd">        :param save_path: default to None, in which case, the downsampled mesh is not saved. If a path is provided,</span>
<span class="sd">                          then the downsampled mesh is saved for each pelves. self.data is also updated with this info</span>
<span class="sd">        :type save_path: str or None</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">decimator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">decimator</span><span class="o">.</span><span class="n">decimate</span><span class="p">(</span><span class="n">hipdata</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span><span class="n">max_num_faces</span><span class="o">=</span><span class="n">max_num_faces</span><span class="p">,</span><span class="n">save_path</span><span class="o">=</span><span class="n">save_path</span><span class="p">,</span><span class="n">step_size</span><span class="o">=</span><span class="n">step_size</span><span class="p">,</span>
                                    <span class="n">max_it</span><span class="o">=</span><span class="n">max_it</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="MeshDecimator"><a class="viewcode-back" href="../data_utils.html#data_utils.MeshDecimator">[docs]</a><span class="k">class</span> <span class="nc">MeshDecimator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base Decimator class that reduces the number of vertices in a triangulated surface. Used in conjunction with HipData.</span>
<span class="sd">    &quot;&quot;&quot;</span>


<div class="viewcode-block" id="MeshDecimator.decimate"><a class="viewcode-back" href="../data_utils.html#data_utils.MeshDecimator.decimate">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">decimate</span><span class="p">(</span><span class="n">hipdata</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;reduces the number of faces in the hipdaya.RPEL and hipdata.LPEL. Will modify attributes of hipdata</span>
<span class="sd">        in particular will modify hipdata.data[&#39;surface&#39;][&#39;LPel&#39;][&#39;points&#39;] and hipdata.data[&#39;surface&#39;][&#39;LPel&#39;][</span>
<span class="sd">        &#39;faces&#39;].</span>


<span class="sd">        :param hipdata:</span>
<span class="sd">        :type hipdata: HipData</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>


<div class="viewcode-block" id="MeshLibDecimator"><a class="viewcode-back" href="../data_utils.html#data_utils.MeshLibDecimator">[docs]</a><span class="k">class</span> <span class="nc">MeshLibDecimator</span><span class="p">(</span><span class="n">MeshDecimator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decimator class that uses meshlib as a backend.&quot;&quot;&quot;</span>
<div class="viewcode-block" id="MeshLibDecimator.decimate"><a class="viewcode-back" href="../data_utils.html#data_utils.MeshLibDecimator.decimate">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">decimate</span><span class="p">(</span><span class="n">hipdata</span><span class="p">:</span><span class="n">HipData</span><span class="p">,</span><span class="n">max_num_faces</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span><span class="n">save_path</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">step_size</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span><span class="n">max_it</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calls meshlib to reduce the number of faces in the RPel and LPel surfaces. Increases the edge size</span>
<span class="sd">        parameter by step_size in a loop until the number of faces in the resulting mesh object is smaller than</span>
<span class="sd">        max_num_faces or until the number of iterations is bigger than max_it. Will modify attributes of hipdata</span>
<span class="sd">        in particular will modify hipdata.data[&#39;surface&#39;][&#39;LPel&#39;][&#39;points&#39;] and hipdata.data[&#39;surface&#39;][&#39;LPel&#39;][</span>
<span class="sd">        &#39;faces&#39;]. Also have the option of saving the new mesh in a specified location and replacing the value of</span>
<span class="sd">        hipdata.data[&#39;surface&#39;][&#39;LPel&#39;][&#39;mesh_loc&#39;] with the new save location of the downsampled mesh</span>

<span class="sd">        :param hipdata: data on which operation is to be perfomed</span>
<span class="sd">        :type hipdata: HipData</span>
<span class="sd">        :param max_num_faces: maximum number of faces</span>
<span class="sd">        :type max_num_faces: int</span>
<span class="sd">        :param save_path: default to None, in which case, the downsampled mesh is not saved. If a path is provided,</span>
<span class="sd">                          then the downsampled mesh is saved for each pelves. self.data is also updated with this info</span>
<span class="sd">        :type save_path: str</span>
<span class="sd">        :param step_size: increments by which the edge length parameter needs to be increased in each loop</span>
<span class="sd">        :type step_size: str</span>
<span class="sd">        :param max_it: maximumg number of times the max_edge_elen argument of mr.DecimateSettings can be increased</span>
<span class="sd">        :type max_it: int</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rpel_path</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">lpel_path</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">rpel_path</span> <span class="o">=</span> <span class="n">hipdata</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">][</span><span class="s1">&#39;RPel&#39;</span><span class="p">][</span><span class="s1">&#39;mesh_loc&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cannot find right pelvis surface&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">lpel_path</span> <span class="o">=</span> <span class="n">hipdata</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">][</span><span class="s1">&#39;LPel&#39;</span><span class="p">][</span><span class="s1">&#39;mesh_loc&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cannot find right pelvis surface&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">path</span><span class="p">,</span><span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">lpel_path</span><span class="p">,</span><span class="n">rpel_path</span><span class="p">],[</span><span class="s1">&#39;LPel&#39;</span><span class="p">,</span><span class="s1">&#39;RPel&#39;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">mr</span><span class="o">.</span><span class="n">loadMesh</span><span class="p">(</span><span class="n">mr</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
                <span class="c1"># decimate it with max possible deviation 0.5:</span>
                <span class="n">settings</span> <span class="o">=</span> <span class="n">mr</span><span class="o">.</span><span class="n">DecimateSettings</span><span class="p">()</span>
                <span class="n">settings</span><span class="o">.</span><span class="n">maxError</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1">#todo: open this up to  the user</span>
                <span class="n">settings</span><span class="o">.</span><span class="n">maxEdgeLen</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="c1">#todo: open this up to the user</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">num_faces_start_r</span> <span class="o">=</span> <span class="n">hipdata</span><span class="o">.</span><span class="n">RPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">3</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="n">num_faces_start_r</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;no right pelvis found&#39;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">num_faces_start_l</span> <span class="o">=</span> <span class="n">hipdata</span><span class="o">.</span><span class="n">LPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">3</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="n">num_faces_start_l</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;no left pelvis found&#39;</span><span class="p">)</span>
                <span class="n">num_faces_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_faces_start_l</span> <span class="o">+</span> <span class="n">num_faces_start_r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">num_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="n">it</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="n">num_faces</span> <span class="o">&gt;</span> <span class="n">max_num_faces</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">mr</span><span class="o">.</span><span class="n">decimateMesh</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span><span class="n">settings</span>
                                             <span class="p">)</span>
                    <span class="n">num_faces</span> <span class="o">=</span> <span class="n">num_faces_start</span><span class="o">-</span><span class="n">result</span><span class="o">.</span><span class="n">facesDeleted</span>
                    <span class="c1">#print(result.facesDeleted)</span>
                    <span class="n">settings</span><span class="o">.</span><span class="n">maxEdgeLen</span> <span class="o">+=</span> <span class="n">step_size</span>
                    <span class="c1">#print(f&#39;edge length={settings.maxEdgeLen}&#39;)</span>
                    <span class="n">it</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">it</span><span class="o">&gt;</span><span class="n">max_it</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;max number of iterations reached, might not have converged&#39;</span><span class="p">)</span>
                        <span class="k">break</span>

                <span class="k">if</span> <span class="n">save_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">file_path</span> <span class="o">=</span> <span class="s1">&#39;tmp.stl&#39;</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">save_path</span><span class="p">):</span> <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">save_path</span><span class="p">)</span>
                    <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_path</span><span class="p">,</span><span class="n">name</span><span class="o">+</span><span class="s1">&#39;.stl&#39;</span><span class="p">)</span>
                    <span class="n">hipdata</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">][</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;mesh_loc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">file_path</span>
                <span class="n">mr</span><span class="o">.</span><span class="n">saveMesh</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span><span class="n">mr</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">file_path</span><span class="p">))</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">stl</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">Mesh</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
                <span class="n">points</span><span class="p">,</span><span class="n">faces</span> <span class="o">=</span> <span class="n">loadSTL</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
                <span class="n">hipdata</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">][</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;points&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span>
                <span class="n">hipdata</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">][</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;faces&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="n">faces</span></div></div>






<span class="k">def</span> <span class="nf">_extract_data</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;scipt that extracts the right socket from two patient files</span>

<span class="sd">    :return: template_points, target_points which represent the socket planes of 2 different patient</span>
<span class="sd">    :rtype: tuple</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt_string</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">.%m.%Y_%H:%M:%S&quot;</span><span class="p">)</span>



    <span class="n">paths</span>         <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;UCLH - Controls&#39;</span><span class="p">,</span><span class="s1">&#39;TOH - Controls&#39;</span><span class="p">,</span><span class="s1">&#39;TOH - FAI&#39;</span><span class="p">,</span><span class="s1">&#39;TOH - DDH&#39;</span><span class="p">]</span>
    <span class="n">location</span>      <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">target_loc</span><span class="p">,</span><span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">files</span>         <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">location</span><span class="p">,</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">location</span><span class="p">)]</span>
    <span class="n">template_file</span> <span class="o">=</span> <span class="n">files</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span>
    <span class="n">target_file</span>   <span class="o">=</span> <span class="n">files</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span>

    <span class="c1"># location = os.path.join(target_loc,paths[0])</span>
    <span class="c1"># files = [os.path.join(location,f) for f in os.listdir(location)]</span>


    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">template_file</span><span class="p">,</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
        <span class="n">template_data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">target_file</span><span class="p">,</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
        <span class="n">target_data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>


    <span class="k">for</span> <span class="n">side</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Right&#39;</span><span class="p">]:</span><span class="c1">#[&#39;Right&#39;,&#39;Left&#39;]:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Ant Lat&#39;</span><span class="p">,</span><span class="s1">&#39;Post Lat&#39;</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">template_points</span> <span class="o">=</span> <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;landmarks&#39;</span><span class="p">][</span><span class="n">side</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="n">key</span><span class="p">]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">template_points</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">target_points</span>   <span class="o">=</span> <span class="n">target_data</span><span class="p">[</span><span class="s1">&#39;landmarks&#39;</span><span class="p">][</span><span class="n">side</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="n">key</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">template_points_</span> <span class="o">=</span> <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;landmarks&#39;</span><span class="p">][</span><span class="n">side</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="n">key</span><span class="p">]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">template_points_</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">template_points</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">template_points</span><span class="p">,</span><span class="n">template_points_</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">target_points_</span>   <span class="o">=</span> <span class="n">target_data</span><span class="p">[</span><span class="s1">&#39;landmarks&#39;</span><span class="p">][</span><span class="n">side</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="n">key</span><span class="p">]</span>
                    <span class="n">target_points</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">target_points</span><span class="p">,</span><span class="n">target_points_</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">k</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cannot find &#39;</span><span class="o">+</span><span class="n">side</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="n">key</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">template_points</span><span class="p">,</span><span class="n">target_points</span>


<span class="k">def</span> <span class="nf">_extract_data_cloud</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;scipt that extracts the right socket from two patient files</span>

<span class="sd">    :return: (template_points,template_data[&#39;surface&#39;][&#39;RPel&#39;]), (target_points,target_data[&#39;surface&#39;][&#39;RPel&#39;])</span>
<span class="sd">            template_points, target_points: poiints of the template, target socket plane,</span>
<span class="sd">            template_data[&#39;surface&#39;][&#39;RPel&#39;], target_data[&#39;surface&#39;][&#39;RPel&#39;] template, Target,m dictionary with keys</span>
<span class="sd">            &#39;faces&#39;, &#39;points&#39;, &#39;mesh_loc&#39;</span>
<span class="sd">            containing the</span>
<span class="sd">            Right</span>
<span class="sd">            pelvis surface</span>
<span class="sd">    :rtype: list of tuples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt_string</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">.%m.%Y_%H:%M:%S&quot;</span><span class="p">)</span>



    <span class="n">paths</span>         <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;UCLH - Controls&#39;</span><span class="p">,</span><span class="s1">&#39;TOH - Controls&#39;</span><span class="p">,</span><span class="s1">&#39;TOH - FAI&#39;</span><span class="p">,</span><span class="s1">&#39;TOH - DDH&#39;</span><span class="p">]</span>
    <span class="n">location</span>      <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">target_loc</span><span class="p">,</span><span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">files</span>         <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">location</span><span class="p">,</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">location</span><span class="p">)]</span>
    <span class="n">template_file</span> <span class="o">=</span> <span class="n">files</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span>
    <span class="n">target_file</span>   <span class="o">=</span> <span class="n">files</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span>

    <span class="c1"># location = os.path.join(target_loc,paths[0])</span>
    <span class="c1"># files = [os.path.join(location,f) for f in os.listdir(location)]</span>


    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">template_file</span><span class="p">,</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
        <span class="n">template_data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">target_file</span><span class="p">,</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
        <span class="n">target_data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>


    <span class="k">for</span> <span class="n">side</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Right&#39;</span><span class="p">]:</span><span class="c1">#[&#39;Right&#39;,&#39;Left&#39;]:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Ant Lat&#39;</span><span class="p">,</span><span class="s1">&#39;Post Lat&#39;</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">template_points</span> <span class="o">=</span> <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;landmarks&#39;</span><span class="p">][</span><span class="n">side</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="n">key</span><span class="p">]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">template_points</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">target_points</span>   <span class="o">=</span> <span class="n">target_data</span><span class="p">[</span><span class="s1">&#39;landmarks&#39;</span><span class="p">][</span><span class="n">side</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="n">key</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">template_points_</span> <span class="o">=</span> <span class="n">template_data</span><span class="p">[</span><span class="s1">&#39;landmarks&#39;</span><span class="p">][</span><span class="n">side</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="n">key</span><span class="p">]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">template_points_</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">template_points</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">template_points</span><span class="p">,</span><span class="n">template_points_</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">target_points_</span>   <span class="o">=</span> <span class="n">target_data</span><span class="p">[</span><span class="s1">&#39;landmarks&#39;</span><span class="p">][</span><span class="n">side</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="n">key</span><span class="p">]</span>
                    <span class="n">target_points</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">target_points</span><span class="p">,</span><span class="n">target_points_</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">k</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cannot find &#39;</span><span class="o">+</span><span class="n">side</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="n">key</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">template_points</span><span class="p">,</span><span class="n">template_data</span><span class="p">),(</span><span class="n">target_points</span><span class="p">,</span><span class="n">target_data</span><span class="p">)</span>


<div class="viewcode-block" id="umeyama"><a class="viewcode-back" href="../data_utils.html#data_utils.umeyama">[docs]</a><span class="k">def</span> <span class="nf">umeyama</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;- http://stackoverflow.com/a/32244818/263061 (solution with scale)</span>
<span class="sd">      - &quot;Least-Squares Rigid Motion Using SVD&quot; (no scale but easy proofs and explains how weights could be added)</span>

<span class="sd">    Rigidly (+scale) aligns two point clouds with know point-to-point correspondences</span>
<span class="sd">    with least-squares error.</span>
<span class="sd">    Returns (scale factor c, rotation matrix R, translation vector t) such that</span>
<span class="sd">      Q = P*cR + t</span>
<span class="sd">    if they align perfectly, or such that</span>
<span class="sd">      SUM over point i ( | P_i*cR + t - Q_i |^2 )</span>
<span class="sd">    is minimised if they don&#39;t align perfectly.</span>

<span class="sd">    :param P: point cloud shape (N1,3)</span>
<span class="sd">    :type P: np.array</span>
<span class="sd">    :param Q: point cloud shape (N2,3)</span>
<span class="sd">    :type Q: np.array</span>
<span class="sd">    :return: list c,R,t where c is the scale transformation shape (1), R is the (3,3) rotation matrix and t is the (</span>
<span class="sd">    1,3) translation vector.</span>
<span class="sd">    :rtype: list(np.array)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">Q</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">n</span><span class="p">,</span><span class="n">dim</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">centeredP</span> <span class="o">=</span> <span class="n">P</span> <span class="o">-</span> <span class="n">P</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">centeredQ</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">-</span> <span class="n">Q</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">centeredP</span><span class="p">),</span><span class="n">centeredQ</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>

    <span class="n">V</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">W</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">0.0</span>

    <span class="k">if</span> <span class="n">d</span><span class="p">:</span>
        <span class="n">S</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">S</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">V</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">V</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">W</span><span class="p">)</span>

    <span class="n">varP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">varP</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>  <span class="c1"># scale factor</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">P</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">R</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">c</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">t</span></div>





<div class="viewcode-block" id="rotation_between_vectors"><a class="viewcode-back" href="../data_utils.html#data_utils.rotation_between_vectors">[docs]</a><span class="k">def</span> <span class="nf">rotation_between_vectors</span><span class="p">(</span><span class="n">normal1</span><span class="p">,</span><span class="n">normal2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the rotation matrix that maps vector normal2 onto vector normal1</span>

<span class="sd">    :param normal1: 3d vector shape (3,)</span>
<span class="sd">    :type normal1: jnp.array</span>
<span class="sd">    :param normal2: 3d vector shape (3,)</span>
<span class="sd">    :type normal2: jnp.array</span>
<span class="sd">    :return: rotation matrix mapping normal2 onto normal1 shape (3,3)</span>
<span class="sd">    :rtype: jnp.array</span>

<span class="sd">    &gt;&gt;&gt; normal1 = jnp.array(np.random.randn(3))</span>
<span class="sd">    &gt;&gt;&gt; normal1 /= jnp.sqrt(jnp.dot(normal1,normal1))</span>
<span class="sd">    &gt;&gt;&gt; normal2 = jnp.array(np.random.randn(3))</span>
<span class="sd">    &gt;&gt;&gt; normal2 /= jnp.sqrt(jnp.dot(normal2,normal2))</span>
<span class="sd">    &gt;&gt;&gt; rot_mat = rotation_between_vectors(normal1,normal2)</span>
<span class="sd">    &gt;&gt;&gt; normal2_trans = jnp.matmul(rot_mat,normal2)</span>
<span class="sd">    &gt;&gt;&gt; print(jnp.sum(jnp.square(normal1-normal2_trans)))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">normal1</span> <span class="o">/=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal1</span><span class="p">,</span><span class="n">normal1</span><span class="p">))</span>
    <span class="n">normal2</span> <span class="o">/=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal2</span><span class="p">,</span><span class="n">normal2</span><span class="p">))</span>

    <span class="n">cosine</span>      <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal1</span><span class="p">,</span><span class="n">normal2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal1</span><span class="p">,</span><span class="n">normal1</span><span class="p">))</span><span class="o">*</span><span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal2</span><span class="p">,</span><span class="n">normal2</span><span class="p">)))</span>
    <span class="n">sine</span>        <span class="o">=</span> <span class="o">-</span><span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">jnp</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">cosine</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">normal1</span><span class="p">,</span><span class="n">normal2</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="o">/</span><span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">u</span><span class="p">))</span>

    <span class="n">rot_mat</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                        <span class="p">[</span><span class="n">cosine</span><span class="o">+</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosine</span><span class="p">),</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosine</span><span class="p">)</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">sine</span><span class="p">,</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosine</span><span class="p">)</span><span class="o">+</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">sine</span><span class="p">],</span>
                        <span class="p">[</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosine</span><span class="p">)</span><span class="o">+</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">sine</span><span class="p">,</span> <span class="n">cosine</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosine</span><span class="p">),</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosine</span><span class="p">)</span><span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">sine</span><span class="p">],</span>
                        <span class="p">[</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosine</span><span class="p">)</span><span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">sine</span><span class="p">,</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosine</span><span class="p">)</span><span class="o">+</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">sine</span><span class="p">,</span><span class="n">cosine</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosine</span><span class="p">)]</span>
                             <span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rot_mat</span></div>

<div class="viewcode-block" id="ralign_2_hips"><a class="viewcode-back" href="../data_utils.html#data_utils.ralign_2_hips">[docs]</a><span class="k">def</span> <span class="nf">ralign_2_hips</span><span class="p">(</span><span class="n">hip1</span><span class="p">:</span> <span class="n">HipData</span><span class="p">,</span><span class="n">hip2</span><span class="p">:</span> <span class="n">HipData</span><span class="p">,</span><span class="n">by</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;RPel&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">list</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Performs rigid alignment of two hips (no scale) by aligning the APP of the 2 hips</span>

<span class="sd">    :param hip1: template Hip, this one is kept in inplace</span>
<span class="sd">    :type hip1: HipData</span>
<span class="sd">    :param hip2: hip to be transformed</span>
<span class="sd">    :type hip2: HipData</span>
<span class="sd">    :param by: options are &#39;RPel&#39; or &#39;LPel&#39; depending on whether the right or left APP are alligned</span>
<span class="sd">    :type by: str</span>
<span class="sd">    :return: list hip1,hip2 of aligned HipData</span>
<span class="sd">    :rtype: list(HipData)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">by</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;rpel&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;aligning right pelves&#39;</span><span class="p">)</span>

        <span class="n">template_points</span> <span class="o">=</span> <span class="n">hip1</span><span class="o">.</span><span class="n">right_socket</span>
        <span class="n">target_points</span> <span class="o">=</span> <span class="n">hip2</span><span class="o">.</span><span class="n">right_socket</span>
        <span class="n">template_plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="o">.</span><span class="n">best_fit</span><span class="p">(</span><span class="n">Points</span><span class="p">(</span><span class="n">template_points</span><span class="p">))</span>
        <span class="n">target_plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="o">.</span><span class="n">best_fit</span><span class="p">(</span><span class="n">Points</span><span class="p">(</span><span class="n">target_points</span><span class="p">))</span>

        <span class="n">rot_mat</span> <span class="o">=</span> <span class="n">rotation_between_vectors</span><span class="p">(</span><span class="n">template_plane</span><span class="o">.</span><span class="n">normal</span><span class="p">,</span><span class="n">target_plane</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>
        <span class="n">mean2</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hip2</span><span class="o">.</span><span class="n">RPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="c1">#translation hip1</span>
        <span class="n">mean1</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hip1</span><span class="o">.</span><span class="n">RPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="c1">#translation hip2</span>


    <span class="k">elif</span> <span class="n">by</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;lpel&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;aligning left pelves&#39;</span><span class="p">)</span>

        <span class="n">template_points</span> <span class="o">=</span> <span class="n">hip1</span><span class="o">.</span><span class="n">left_socket</span>
        <span class="n">target_points</span> <span class="o">=</span> <span class="n">hip2</span><span class="o">.</span><span class="n">left_socket</span>
        <span class="n">template_plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="o">.</span><span class="n">best_fit</span><span class="p">(</span><span class="n">Points</span><span class="p">(</span><span class="n">template_points</span><span class="p">))</span>
        <span class="n">target_plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="o">.</span><span class="n">best_fit</span><span class="p">(</span><span class="n">Points</span><span class="p">(</span><span class="n">target_points</span><span class="p">))</span>

        <span class="n">rot_mat</span> <span class="o">=</span> <span class="n">rotation_between_vectors</span><span class="p">(</span><span class="n">template_plane</span><span class="o">.</span><span class="n">normal</span><span class="p">,</span><span class="n">target_plane</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>
        <span class="n">mean2</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hip2</span><span class="o">.</span><span class="n">LPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">mean1</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hip1</span><span class="o">.</span><span class="n">LPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;aligning the whole thing&#39;</span><span class="p">)</span>

        <span class="n">template_points</span> <span class="o">=</span> <span class="n">hip1</span><span class="o">.</span><span class="n">APP_coords</span>
        <span class="n">target_points</span> <span class="o">=</span> <span class="n">hip2</span><span class="o">.</span><span class="n">APP_coords</span>
        <span class="c1"># template_plane = Plane.best_fit(Points(template_points))</span>
        <span class="c1"># target_plane = Plane.best_fit(Points(target_points))</span>
        <span class="n">c</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">t</span> <span class="o">=</span> <span class="n">umeyama</span><span class="p">(</span><span class="n">target_points</span><span class="p">,</span><span class="n">template_points</span><span class="p">)</span>

<span class="c1">#        rot_mat = rotation_between_vectors(template_plane.normal,target_plane.normal)</span>
        <span class="n">rot_mat</span> <span class="o">=</span> <span class="n">R</span>
        <span class="n">mean2</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">hip2</span><span class="o">.</span><span class="n">LPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">hip2</span><span class="o">.</span><span class="n">RPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">mean1</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">hip1</span><span class="o">.</span><span class="n">LPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">hip1</span><span class="o">.</span><span class="n">RPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">hip1</span><span class="o">.</span><span class="n">trans_vect</span> <span class="o">=</span> <span class="n">mean1</span>
    <span class="n">hip2</span><span class="o">.</span><span class="n">rot_mat</span>    <span class="o">=</span> <span class="n">rot_mat</span>
    <span class="n">hip2</span><span class="o">.</span><span class="n">trans_vect</span> <span class="o">=</span> <span class="n">mean2</span>

    <span class="k">return</span> <span class="n">hip1</span><span class="p">,</span><span class="n">hip2</span></div>


<div class="viewcode-block" id="loadSTL"><a class="viewcode-back" href="../data_utils.html#data_utils.loadSTL">[docs]</a><span class="k">def</span> <span class="nf">loadSTL</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;loads the vetices and faces from an stl file</span>

<span class="sd">    :param filename: path to stl file</span>
<span class="sd">    :type filename: str</span>
<span class="sd">    :return: points, faces where points[faces[:,i]] are the i-th coordinate of the triangles.</span>
<span class="sd">    :rtype: list(np.array)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">Mesh</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">points</span><span class="p">,</span><span class="n">faces</span></div>


<div class="viewcode-block" id="stl2mesh3d"><a class="viewcode-back" href="../data_utils.html#data_utils.stl2mesh3d">[docs]</a><span class="k">def</span> <span class="nf">stl2mesh3d</span><span class="p">(</span><span class="n">stl_mesh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; stl_mesh is read by nympy-stl from a stl file; it is  an array of faces/triangles (i.e. three 3d points) this function extracts the unique vertices and the lists I, J, K to define a Plotly mesh3d</span>

<span class="sd">    :param stl_mesh:</span>
<span class="sd">    :type stl_mesh:</span>
<span class="sd">    :return:</span>
<span class="sd">    :rtype:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">stl_mesh</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">shape</span> <span class="c1">#(p, 3, 3)</span>
    <span class="c1"># the array stl_mesh.vectors.reshape(p*q, r) can contain multiple copies of the same vertex;</span>
    <span class="c1"># extract unique vertices from all mesh triangles</span>
    <span class="n">vertices</span><span class="p">,</span> <span class="n">ixr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">stl_mesh</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">ixr</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">)])</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">ixr</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">)])</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">ixr</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">K</span></div>

<div class="viewcode-block" id="points2mesh3d"><a class="viewcode-back" href="../data_utils.html#data_utils.points2mesh3d">[docs]</a><span class="k">def</span> <span class="nf">points2mesh3d</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Turns a point cloud surface into a format that is plottable by plotly, the input should be the points</span>
<span class="sd">    attribute to a numpy.stl loaded mesh file. Alternatively, points need to be loaded from the pickle output of</span>
<span class="sd">    DataCleaning._to_pickle</span>

<span class="sd">    :param points: array shape [npoints*3,3]. points attribute of a mesh object or</span>
<span class="sd">    :type points: array</span>
<span class="sd">    :return: vertices,I,J,K</span>
<span class="sd">    :rtype: list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># stl_mesh is read by nympy-stl from a stl file; it is  an array of faces/triangles (i.e. three 3d points)</span>
    <span class="c1"># this function extracts the unique vertices and the lists I, J, K to define a Plotly mesh3d</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span> <span class="c1">#(p, 3, 3)</span>
    <span class="c1"># the array stl_mesh.vectors.reshape(p*q, r) can contain multiple copies of the same vertex;</span>
    <span class="c1"># extract unique vertices from all mesh triangles</span>
    <span class="n">vertices</span><span class="p">,</span> <span class="n">ixr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">ixr</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">)])</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">ixr</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">)])</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">ixr</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">K</span></div>



<span class="k">def</span> <span class="nf">_test_modules</span><span class="p">():</span>
    <span class="n">template_points</span><span class="p">,</span><span class="n">target_points</span> <span class="o">=</span> <span class="n">_extract_data</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">template_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">target_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1">#assert not np.equal(template_points,target_points)</span>

    <span class="n">template_points_proc</span><span class="p">,</span><span class="n">target_points_proc</span><span class="p">,</span><span class="n">size</span> <span class="o">=</span> <span class="n">_embed_points_in_array</span><span class="p">(</span><span class="n">template_points</span><span class="p">,</span><span class="n">target_points</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;size of embedded template points is </span><span class="si">{</span><span class="n">template_points_proc</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1">#check dimension</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span><span class="o">==</span><span class="mi">3</span>
    <span class="c1">#check embedding</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="n">size</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">template_points_proc</span><span class="p">,</span><span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="n">size</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">target_points_proc</span><span class="p">,</span><span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">target_points_proc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">template_points_proc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">_make_distance_transform</span><span class="p">(</span><span class="n">points</span> <span class="o">=</span> <span class="n">template_points_proc</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span><span class="n">ncpus</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="c1">#check dimension of dt matches dimension of size</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="n">size</span><span class="p">)</span>
    <span class="n">dist_vals</span> <span class="o">=</span> <span class="n">eval_distance</span><span class="p">(</span><span class="n">template_points_proc</span><span class="p">,</span><span class="n">dist</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">dist</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist_vals</span><span class="p">)</span><span class="o">/</span><span class="n">template_points_proc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;distance for templare_points_proc is </span><span class="si">{</span><span class="n">dist</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1">#assert dist &lt; 10e-3</span>
    <span class="n">dist_vals_exact</span> <span class="o">=</span> <span class="n">eval_distance</span><span class="p">(</span><span class="n">template_points_proc</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span><span class="n">dist</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">dist_exact</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist_vals</span><span class="p">)</span><span class="o">/</span><span class="n">template_points_proc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">dist_exact</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">-</span><span class="mi">3</span>

    <span class="n">dist_vals_exact</span> <span class="o">=</span> <span class="n">jax_eval_distance</span><span class="p">(</span><span class="n">template_points_proc</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span><span class="n">dist</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">dist_exact</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist_vals</span><span class="p">)</span><span class="o">/</span><span class="n">template_points_proc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">dist_exact</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">-</span><span class="mi">3</span>

    <span class="k">for</span> <span class="n">ncpus</span> <span class="ow">in</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="n">dt</span> <span class="o">=</span> <span class="n">_make_distance_transform</span><span class="p">(</span><span class="n">points</span> <span class="o">=</span> <span class="n">template_points_proc</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span><span class="n">ncpus</span><span class="o">=</span><span class="n">ncpus</span><span class="p">)</span>
        <span class="n">time_taken_edt</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start</span>
        <span class="n">my_string</span> <span class="o">=</span> <span class="s2">&quot;time for github dt </span><span class="si">{:}</span><span class="s2"> with </span><span class="si">{:}</span><span class="s2"> cpus&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time_taken_edt</span><span class="p">,</span><span class="n">ncpus</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">my_string</span><span class="p">)</span>


    <span class="n">points</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">angle</span>  <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">Rx</span> <span class="o">=</span> <span class="n">jax_roll_matrix</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">Ry</span> <span class="o">=</span> <span class="n">jax_pitch_matrix</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">Rz</span> <span class="o">=</span> <span class="n">jax_yaw_matrix</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">rot_matrix</span> <span class="o">=</span> <span class="n">jax_rotation_matrix3d</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span><span class="n">angle</span><span class="p">,</span><span class="n">angle</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Rx</span><span class="p">,</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span><span class="o">&lt;</span><span class="mf">10e-5</span>
    <span class="k">assert</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Ry</span><span class="p">,</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span><span class="o">&lt;</span><span class="mf">10e-5</span>
    <span class="k">assert</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Rz</span><span class="p">,</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span><span class="o">&lt;</span><span class="mf">10e-5</span>
    <span class="k">assert</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rot_matrix</span><span class="o">-</span><span class="n">jnp</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Rz</span><span class="p">,</span><span class="n">jnp</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Ry</span><span class="p">,</span><span class="n">Rx</span><span class="p">)))</span><span class="o">&lt;</span><span class="mf">10e-5</span>
    <span class="n">rot_matrix</span> <span class="o">=</span> <span class="n">jax_rotation_matrix3d</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Rotation matrix size </span><span class="si">{</span><span class="n">rot_matrix</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;points  size </span><span class="si">{</span><span class="n">template_points_proc</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;points transpose size </span><span class="si">{</span><span class="n">template_points_proc</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rot_matrix</span><span class="p">,</span><span class="n">template_points_proc</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">-</span><span class="n">template_points_proc</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">&lt;</span><span class="mf">10e-5</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rot_matrix</span><span class="p">,</span><span class="n">points</span><span class="p">))</span>

    <span class="n">params</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;evaluating distance&#39;</span><span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">affine_cost</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">template_points_proc</span><span class="p">,</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">loss</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">-</span><span class="mi">3</span>





<span class="k">def</span> <span class="nf">_test_vector_rotation</span><span class="p">():</span>
    <span class="n">normal1</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">normal1</span> <span class="o">/=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal1</span><span class="p">,</span><span class="n">normal1</span><span class="p">))</span>
    <span class="n">normal2</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">normal2</span> <span class="o">/=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal2</span><span class="p">,</span><span class="n">normal2</span><span class="p">))</span>
    <span class="n">rot_mat</span> <span class="o">=</span> <span class="n">rotation_between_vectors</span><span class="p">(</span><span class="n">normal1</span><span class="p">,</span><span class="n">normal2</span><span class="p">)</span>
    <span class="n">normal2_mapped</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rot_mat</span><span class="p">,</span><span class="n">normal2</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;========Lin-alg=================&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;mapped normal </span><span class="si">{</span><span class="n">normal2_mapped</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;original normal </span><span class="si">{</span><span class="n">normal1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">normal2_mapped</span><span class="o">-</span><span class="n">normal1</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">-</span><span class="mi">4</span>



<span class="k">def</span> <span class="nf">_test_downsampling</span><span class="p">():</span>
    <span class="n">decimator</span> <span class="o">=</span> <span class="n">MeshLibDecimator</span>
    <span class="n">file_path</span> <span class="o">=</span> <span class="s1">&#39;/home/adwaye/PycharmProjects/hip_shape/data/Segmentation_and_landmarks_processed/TOH - Controls/C4.p&#39;</span>
    <span class="n">hip_data</span> <span class="o">=</span> <span class="n">HipData</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span><span class="n">decimator</span><span class="p">)</span>
    <span class="n">left_plot1</span><span class="p">,</span><span class="n">right_plot1</span> <span class="o">=</span> <span class="n">hip_data</span><span class="o">.</span><span class="n">get_plotly_graph</span><span class="p">()</span>
    <span class="n">max_num_faces</span> <span class="o">=</span> <span class="n">hip_data</span><span class="o">.</span><span class="n">RPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">10</span>
    <span class="n">save_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;/home/adwaye/PycharmProjects/FlowGPLVM/data/mesh_downsample_</span><span class="si">{</span><span class="n">max_num_faces</span><span class="si">}</span><span class="s1">/TOH - Controls/C4&#39;</span>
    <span class="n">os</span><span class="o">.</span><span class="n">removedirs</span><span class="p">(</span><span class="n">save_path</span><span class="p">)</span>
    <span class="n">rpel_num_faces</span> <span class="o">=</span> <span class="n">hip_data</span><span class="o">.</span><span class="n">RPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">3</span>
    <span class="n">lpel_num_faces</span> <span class="o">=</span> <span class="n">hip_data</span><span class="o">.</span><span class="n">LPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">3</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;pre-decimate number of faces in RPel=</span><span class="si">{</span><span class="n">rpel_num_faces</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;pre-decimate number of faces in LPel=</span><span class="si">{</span><span class="n">lpel_num_faces</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">hip_data</span><span class="o">.</span><span class="n">decimate</span><span class="p">(</span><span class="n">max_num_faces</span><span class="o">=</span><span class="n">max_num_faces</span><span class="p">,</span>
                      <span class="n">save_path</span><span class="o">=</span><span class="n">save_path</span><span class="p">)</span>
    <span class="n">hip_data</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="s1">&#39;/home/adwaye/PycharmProjects/FlowGPLVM/data/TOH - &#39;</span>
                       <span class="s1">&#39;Controls&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;post decimate number of faces in RPel=</span><span class="si">{</span><span class="n">hip_data</span><span class="o">.</span><span class="n">RPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">3</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;post decimate number of faces in LPel=</span><span class="si">{</span><span class="n">hip_data</span><span class="o">.</span><span class="n">LPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">3</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">rpel_num_faces</span><span class="o">&gt;</span><span class="n">hip_data</span><span class="o">.</span><span class="n">RPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">3</span>
    <span class="k">assert</span> <span class="n">lpel_num_faces</span><span class="o">&gt;</span><span class="n">hip_data</span><span class="o">.</span><span class="n">LPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">3</span>
    <span class="c1"># assert hip_data.RPEL[0].shape[0]//3 &lt; max_num_faces</span>
    <span class="c1"># assert hip_data.LPEL[0].shape[0]//3 &lt; max_num_faces</span>
    <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;RPel.stl&#39;</span><span class="p">,</span><span class="s1">&#39;LPel.stl&#39;</span><span class="p">]:</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_path</span><span class="p">,</span><span class="n">fname</span><span class="p">))</span>
        <span class="n">points</span><span class="p">,</span><span class="n">faces</span> <span class="o">=</span> <span class="n">loadSTL</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_path</span><span class="p">,</span><span class="n">fname</span><span class="p">))</span>

    <span class="n">left_plot2</span><span class="p">,</span><span class="n">right_plot2</span> <span class="o">=</span> <span class="n">hip_data</span><span class="o">.</span><span class="n">get_plotly_graph</span><span class="p">()</span>
    <span class="kn">from</span> <span class="nn">plotly.subplots</span> <span class="kn">import</span> <span class="n">make_subplots</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">make_subplots</span><span class="p">(</span><span class="n">rows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">cols</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">specs</span><span class="o">=</span><span class="p">[[{</span><span class="s1">&#39;is_3d&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">}],</span>
                               <span class="p">[{</span><span class="s1">&#39;is_3d&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">}]],</span>
                        <span class="n">print_grid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">subplot_titles</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;Original Mesh&quot;</span><span class="p">,</span> <span class="s2">&quot;Downsampled mesh&quot;</span><span class="p">))</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span>
        <span class="n">left_plot1</span><span class="p">,</span>

        <span class="n">row</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">col</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">secondary_y</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span>
        <span class="n">right_plot1</span><span class="p">,</span>

        <span class="n">row</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">col</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">secondary_y</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span>
        <span class="n">left_plot2</span><span class="p">,</span>

        <span class="n">row</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">col</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">secondary_y</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span>
        <span class="n">right_plot2</span><span class="p">,</span>

        <span class="n">row</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">col</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">secondary_y</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="c1"># assert points.shape[0]//3 &lt; max_num_faces</span>




<span class="k">def</span> <span class="nf">_test_rotation</span><span class="p">():</span>
    <span class="n">template_shape</span> <span class="o">=</span> <span class="n">HipData</span><span class="p">(</span><span class="s1">&#39;/home/adwaye/PycharmProjects/hip_shape/data/Segmentation_and_landmarks_processed/TOH - Controls/C4.p&#39;</span><span class="p">)</span>
    <span class="n">mean_pos</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">template_shape</span><span class="o">.</span><span class="n">RPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">template_shape</span><span class="o">.</span><span class="n">APP_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1">#template_shape.trans_vect = np.mean(template_shape.RPEL[0],axis=0,keepdims=True)</span>
    <span class="n">target_shape</span> <span class="o">=</span> <span class="n">HipData</span><span class="p">(</span><span class="s1">&#39;/home/adwaye/PycharmProjects/hip_shape/data/Segmentation_and_landmarks_processed/TOH - &#39;</span>
                        <span class="s1">&#39;Controls/C8.p&#39;</span><span class="p">)</span>
    <span class="c1">#target_shape.trans_vect = np.mean(target_shape.RPEL[0],axis=0,keepdims=True)</span>

    <span class="n">template_shape</span><span class="p">,</span><span class="n">target_shape</span> <span class="o">=</span> <span class="n">ralign_2_hips</span><span class="p">(</span><span class="n">template_shape</span><span class="p">,</span><span class="n">target_shape</span><span class="p">,</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;RPel&#39;</span><span class="p">)</span>

    <span class="c1"># template_points = template_shape.right_socket</span>
    <span class="c1"># target_points = target_shape.right_socket</span>
    <span class="c1">#</span>
    <span class="c1"># template_plane = Plane.best_fit(Points(template_points))</span>
    <span class="c1"># target_plane = Plane.best_fit(Points(target_points))</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1"># rot_mat = rotation_between_vectors(template_plane.normal,target_plane.normal)</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1"># target_shape.rot_mat = rot_mat</span>
    <span class="c1"># target_shape.trans_vect = -np.mean(target_shape.RPEL[0],axis=0,keepdims=True)</span>
    <span class="c1"># template_shape.trans_vect = -np.mean(template_shape.RPEL[0],axis=0,keepdims=True)</span>

    <span class="n">left_plot2</span><span class="p">,</span><span class="n">right_plot2</span>   <span class="o">=</span> <span class="n">target_shape</span><span class="o">.</span><span class="n">get_plotly_graph</span><span class="p">()</span>
    <span class="n">left_plot1</span><span class="p">,</span><span class="n">right_plot1</span> <span class="o">=</span> <span class="n">template_shape</span><span class="o">.</span><span class="n">get_plotly_graph</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span>
    <span class="n">fig</span> <span class="o">=</span>  <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">left_plot1</span>
                          <span class="p">,</span><span class="n">left_plot2</span>
                          <span class="p">,</span><span class="n">right_plot1</span>
                          <span class="p">,</span><span class="n">right_plot2</span>
                          <span class="p">])</span>

    <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>



<div class="viewcode-block" id="downsample_data"><a class="viewcode-back" href="../data_utils.html#data_utils.downsample_data">[docs]</a><span class="k">def</span> <span class="nf">downsample_data</span><span class="p">(</span><span class="n">folders</span><span class="p">:</span><span class="nb">list</span><span class="p">,</span>
                    <span class="n">reduction_factor</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decimates hip meshes stored in pickle files stored in paths given by elements of folders. The downsampled meshes are stored in new folders whose name are just the original folder appended with the reduction factor</span>

<span class="sd">    :param folders: list of folders where each element should contain a pickle file of the type output by</span>
<span class="sd">                    data_cleaning._to_pickle</span>
<span class="sd">    :type folders: list[str]</span>
<span class="sd">    :param reduction_factor: amount by which the number of faces should be reduced. If initial mesh has N points</span>
<span class="sd">                             then the final mesh will have &lt;N/10 points</span>
<span class="sd">    :type reduction_factor: int</span>
<span class="sd">    :return: None</span>
<span class="sd">    :rtype: None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">decimator</span> <span class="o">=</span> <span class="n">MeshLibDecimator</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">folder</span> <span class="ow">in</span> <span class="n">folders</span><span class="p">:</span>
        <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;p&#39;</span><span class="p">]</span>
        <span class="n">save_path_stl</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;data/stl_downsample_</span><span class="si">{</span><span class="n">reduction_factor</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">folder</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">save_path_p</span>   <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;data/Segmentation_and_landmarks_downsample_</span><span class="si">{</span><span class="n">reduction_factor</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">folder</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;==============&#39;</span><span class="p">)</span>
            <span class="n">stl_fpath</span>    <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_path_stl</span><span class="p">,</span><span class="n">file</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>



            <span class="n">hip_data</span>  <span class="o">=</span> <span class="n">HipData</span><span class="p">(</span><span class="n">pickle_path</span><span class="o">=</span><span class="n">file</span><span class="p">,</span><span class="n">decimator</span><span class="o">=</span><span class="n">decimator</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">num_faces_start_r</span> <span class="o">=</span> <span class="n">hip_data</span><span class="o">.</span><span class="n">RPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">3</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">num_faces_start_r</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;no right pelvis found&#39;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">num_faces_start_l</span> <span class="o">=</span> <span class="n">hip_data</span><span class="o">.</span><span class="n">LPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">3</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">num_faces_start_l</span> <span class="o">=</span><span class="mi">0</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;no left pelvis found&#39;</span><span class="p">)</span>
            <span class="n">num_faces_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_faces_start_l</span><span class="o">+</span><span class="n">num_faces_start_r</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
            <span class="k">if</span> <span class="n">num_faces_start</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;processing </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;initial number of faces right=</span><span class="si">{</span><span class="n">num_faces_start_r</span><span class="si">}</span><span class="s1">, left=</span><span class="si">{</span><span class="n">num_faces_start_l</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">hip_data</span><span class="o">.</span><span class="n">decimate</span><span class="p">(</span><span class="n">save_path</span><span class="o">=</span><span class="n">stl_fpath</span><span class="p">,</span><span class="n">max_num_faces</span><span class="o">=</span><span class="n">num_faces_start</span><span class="o">//</span><span class="n">reduction_factor</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">num_faces_end_r</span> <span class="o">=</span> <span class="n">hip_data</span><span class="o">.</span><span class="n">RPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">3</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="n">num_faces_end_r</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">num_faces_end_l</span> <span class="o">=</span> <span class="n">hip_data</span><span class="o">.</span><span class="n">LPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">3</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="n">num_faces_end_l</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;final number of faces right=</span><span class="si">{</span><span class="n">num_faces_end_r</span><span class="si">}</span><span class="s1">, left=</span><span class="si">{</span><span class="n">num_faces_end_l</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">hip_data</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">location</span><span class="o">=</span><span class="n">save_path_p</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;saved downsampled pickle file at </span><span class="si">{</span><span class="n">hip_data</span><span class="o">.</span><span class="n">pickle_path</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;saved downsampled stl file(s) at </span><span class="si">{</span><span class="n">stl_fpath</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="c1">#checking if</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">rpel_path</span> <span class="o">=</span> <span class="n">hip_data</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">][</span><span class="s1">&#39;RPel&#39;</span><span class="p">][</span><span class="s1">&#39;mesh_loc&#39;</span><span class="p">]</span>
                    <span class="k">assert</span> <span class="n">rpel_path</span><span class="o">==</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stl_fpath</span><span class="p">,</span><span class="s1">&#39;RPel.stl&#39;</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stl_fpath</span><span class="p">,</span><span class="s1">&#39;RPel.stl&#39;</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;kk fane, pna koT drwat&#39;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lpel_path</span> <span class="o">=</span> <span class="n">hip_data</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;surface&#39;</span><span class="p">][</span><span class="s1">&#39;LPel&#39;</span><span class="p">][</span><span class="s1">&#39;mesh_loc&#39;</span><span class="p">]</span>
                    <span class="k">assert</span> <span class="n">lpel_path</span><span class="o">==</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stl_fpath</span><span class="p">,</span><span class="s1">&#39;LPel.stl&#39;</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stl_fpath</span><span class="p">,</span><span class="s1">&#39;LPel.stl&#39;</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;kk fane, pna koT goss&#39;</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">hip_data</span><span class="o">.</span><span class="n">pickle_path</span> <span class="o">==</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_path_p</span><span class="p">,</span><span class="n">file</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>



<span class="k">def</span> <span class="nf">_test_downsampled_data</span><span class="p">(</span><span class="n">f_path</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;data/Segmentation_and_landmarks_downsample_10/TOH - Controls/C4.p&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;plots a saved downsampled data point to see how it is doing</span>

<span class="sd">    :param f_path:</span>
<span class="sd">    :type f_path:</span>
<span class="sd">    :return:</span>
<span class="sd">    :rtype:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hip_data</span> <span class="o">=</span> <span class="n">HipData</span><span class="p">(</span><span class="n">f_path</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;num points in left pelvis=</span><span class="si">{</span><span class="n">hip_data</span><span class="o">.</span><span class="n">LPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;no left pelvis&#39;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;num points in right pelvis=</span><span class="si">{</span><span class="n">hip_data</span><span class="o">.</span><span class="n">RPEL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;no left pelvis&#39;</span><span class="p">)</span>
    <span class="n">r_plot</span><span class="p">,</span><span class="n">l_plot</span> <span class="o">=</span> <span class="n">hip_data</span><span class="o">.</span><span class="n">get_plotly_graph</span><span class="p">()</span>
    <span class="n">fig</span> <span class="o">=</span>  <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">r_plot</span>
                          <span class="p">,</span><span class="n">l_plot</span>

                          <span class="p">])</span>

    <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>



<span class="c1">#need to embed the curves into an array:</span>
<span class="c1">#calculating size of the array to allocate for the distance transform</span>
<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1">#_test_downsampling()</span>
    <span class="c1">#_test_modules()</span>
    <span class="n">path</span> <span class="o">=</span> <span class="s1">&#39;data/Segmentation_and_landmarks_processed/TOH - Controls/C30.p&#39;</span>
    <span class="n">hip_data</span> <span class="o">=</span> <span class="n">HipData</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="c1"># downsample_data(folders = [os.path.join(target_loc,f) for f in os.listdir(target_loc)][1:],reduction_factor=20)</span>






    <span class="c1">#_test_rotation()</span>






</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2022, Adwaye Rambojun.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>